<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>悬浮音乐播放器</title>
    <link href="/2023/12/25/%E6%82%AC%E6%B5%AE%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2023/12/25/%E6%82%AC%E6%B5%AE%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装aplayer插件"><a href="#1-安装aplayer插件" class="headerlink" title="1.安装aplayer插件"></a>1.安装aplayer插件</h1><p><a href="https://github.com/DIYgod/APlayer/releases/tag/v1.10.1">下载地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/aplayer%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80.png" srcset="/img/loading.gif" lazyload alt="image-20231224184320405"></p><p>下载完毕之后，复制压缩包中的dist文件夹到主题目录下的source下</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/dist.png" srcset="/img/loading.gif" lazyload alt="image-20231224184732526"></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/source.png" srcset="/img/loading.gif" lazyload alt="image-20231224184813762"></p><p>在主题目录中找到<code>_config.yml</code>文件,进行添加如下内容:</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/custom_html.png" srcset="/img/loading.gif" lazyload alt="image-20231224185715183"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 自定义底部 HTML 内容（位于 footer 上方），也可用于外部引入 js css 这些操作，注意不要和 post.custom 配置冲突<br>custom_html: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/dist/APlayer.min.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aplayer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/dist/APlayer.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/diy/music.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&gt; &#x27;<br></code></pre></td></tr></table></figure><h1 id="2-配置JS组件"><a href="#2-配置JS组件" class="headerlink" title="2. 配置JS组件"></a>2. 配置JS组件</h1><p>在js文件夹中新建一个diy文件夹，在diy文件夹中新建一个music.js文件。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/music.png" srcset="/img/loading.gif" lazyload alt="image-20231224185122031"></p><p>对<code>music.js</code>文件进行如下编辑:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c">const ap = new APlayer(&#123;<br>    container: document.getElementById(&#x27;aplayer&#x27;),<br>    fixed: true,<br>autoplay: true, <span class="hljs-comment">//自动播放</span><br>    audio: [<br>&#123;<br>        name: <span class="hljs-string">&quot;红昭愿&quot;</span>,<br>        artist: &#x27; 音阙诗听&#x27;,<br>        url: &#x27;https://m701.music.126.net/<span class="hljs-number">20231224185423</span>/d<span class="hljs-number">4372</span>d<span class="hljs-number">272831</span>c6a1cc3e<span class="hljs-number">2197</span>5ba409ec/jdymusic/obj/wo3DlMOGwrbDjj7DisKw/<span class="hljs-number">2848166698</span>0/ce44/16ac/7e54/004d523aa<span class="hljs-number">1144</span>0c15a2fb<span class="hljs-number">265404</span>a<span class="hljs-number">2614</span>.mp3&#x27;,<br>        cover: &#x27;http://p1.music.126.net/8ltR3o9R8uJ9_5Cc71cDhA==/<span class="hljs-number">10995116295124</span><span class="hljs-number">2154</span>.jpg?param=177y177&#x27;,<br>    &#125;,<br>]<br>&#125;);<br>一般只修改name、artist、url、cover即可<br></code></pre></td></tr></table></figure><h1 id="3-找寻音乐链接-下面的以对网易云歌曲为例"><a href="#3-找寻音乐链接-下面的以对网易云歌曲为例" class="headerlink" title="3. 找寻音乐链接(下面的以对网易云歌曲为例)"></a>3. 找寻音乐链接(下面的以对网易云歌曲为例)</h1><p>打开网易云音乐网页版，随便找到一首歌，播放。它的url形如：<a href="https://music.163.com/#/album?id=35114938%E3%80%82">https://music.163.com/#/album?id=35114938。</a></p><p>方法一: <strong>直接获取</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E7%BA%A2%E6%98%AD%E6%84%BF.png" srcset="/img/loading.gif" lazyload alt="image-20231224190335727"></p><p>然后将前者的id值套用到后者链接中xxxxxx位置 <a href="http://music.163.com/song/media/outer/url?id=xxxxxxx.mp3">http://music.163.com/song/media/outer/url?id=xxxxxxx.mp3</a> 。也就是我们要填的url。对于获取cover，直接在网页版的封面图片上右击复制图像链接即可获得。(有的歌曲可以找到对应的url真实链接)</p><p>方法二: <strong>点击下面的生成外联播放器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E7%BA%A2%E6%98%AD%E6%84%BF%E5%A4%96%E9%93%BE%E6%92%AD%E6%94%BE%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt="image-20231224190116586"></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E7%BA%A2%E6%98%AD%E6%84%BF2.png" srcset="/img/loading.gif" lazyload alt="image-20231224220445224"></p><p>按F12调出开发者工具,依次点击网络、媒体找到歌曲的真实链接地址。复制链接地址，填写<code>music.js</code>中。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E7%BA%A2%E6%98%AD%E6%84%BF3.png" srcset="/img/loading.gif" lazyload alt="image-20231224221142458"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aplayer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github+PicGo &gt; 一个免费的图床</title>
    <link href="/2023/12/25/Github-PicGo-%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/12/25/Github-PicGo-%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="Github-PicGo-一个免费的图床"><a href="#Github-PicGo-一个免费的图床" class="headerlink" title="Github+PicGo &gt; 一个免费的图床"></a>Github+PicGo &gt; 一个免费的图床</h1><blockquote><p>起因：因搭建博客需要插入图片，而Markdown中插入图片又太麻烦了。因为在网上搜索一下之后，找到了一种利用GitHub+PicGol来搭建一个免费的图床。</p><p><strong>如果已有GitHub账号，可以直接跳到步骤10。</strong></p></blockquote><h1 id="1-注册一个GitHub账号-点击一下官网链接"><a href="#1-注册一个GitHub账号-点击一下官网链接" class="headerlink" title="1. 注册一个GitHub账号,点击一下官网链接"></a>1. 注册一个GitHub账号,点击一下<a href="https://github.com/" title="GitHub">官网链接</a></h1><h1 id="2-点击右上角注册按钮sign-up，来到注册页面。"><a href="#2-点击右上角注册按钮sign-up，来到注册页面。" class="headerlink" title="2. 点击右上角注册按钮sign up，来到注册页面。"></a>2. 点击右上角注册按钮sign up，来到注册页面。</h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/GitHub%E5%AE%98%E7%BD%91.png" srcset="/img/loading.gif" lazyload alt="image-20231223183919704"></p><h1 id="3-注册页面内输入你的邮箱，点击Continue"><a href="#3-注册页面内输入你的邮箱，点击Continue" class="headerlink" title="3. 注册页面内输入你的邮箱，点击Continue"></a>3. 注册页面内输入你的邮箱，点击<code>Continue</code><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E9%82%AE%E7%AE%B1.png" srcset="/img/loading.gif" lazyload alt="image-20231223184625724"></h1><h1 id="4-输入你想要设置的密码和用户名"><a href="#4-输入你想要设置的密码和用户名" class="headerlink" title="4. 输入你想要设置的密码和用户名"></a>4. 输入你想要设置的密码和用户名</h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E5%AF%86%E7%A0%81.png" srcset="/img/loading.gif" lazyload alt="image-20231223185426487"></p><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E7%94%A8%E6%88%B7%E5%90%8D.png" srcset="/img/loading.gif" lazyload alt="image-20231223185349272"></p><h1 id="5-进行相应的验证，点击-create-account-后-，会出现这个界面"><a href="#5-进行相应的验证，点击-create-account-后-，会出现这个界面" class="headerlink" title="5. 进行相应的验证，点击 create account 后 ，会出现这个界面"></a>5. 进行相应的验证，点击 create account 后 ，会出现这个界面</h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E9%AA%8C%E8%AF%81%E7%A0%81.png" srcset="/img/loading.gif" lazyload alt="image-20231223185816330"></p><h1 id="6-这时邮箱就会收到一封邮件，输入邮件中的数字页面会自动跳转"><a href="#6-这时邮箱就会收到一封邮件，输入邮件中的数字页面会自动跳转" class="headerlink" title="6. 这时邮箱就会收到一封邮件，输入邮件中的数字页面会自动跳转"></a>6. 这时邮箱就会收到一封邮件，输入邮件中的数字页面会自动跳转</h1><h1 id="7-进行个性化设置"><a href="#7-进行个性化设置" class="headerlink" title="7. 进行个性化设置"></a>7. 进行个性化设置</h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E4%B8%AA%E6%80%A7%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="image-20231223185948784"></p><h1 id="8-成功页面"><a href="#8-成功页面" class="headerlink" title="8.成功页面"></a>8.成功页面</h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F%E9%A1%B5%E9%9D%A2.png" srcset="/img/loading.gif" lazyload alt="image-20231223190045925"></p><h1 id="9-下次登录时，需要点击旁边的sign-in，进入登录页面"><a href="#9-下次登录时，需要点击旁边的sign-in，进入登录页面" class="headerlink" title="9.下次登录时，需要点击旁边的sign in，进入登录页面"></a>9.下次登录时，需要点击旁边的sign in，进入登录页面</h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png" srcset="/img/loading.gif" lazyload alt="image-20231223190154516"></p><h1 id="10-点击Create-repository-创建一个仓库。"><a href="#10-点击Create-repository-创建一个仓库。" class="headerlink" title="10. 点击Create repository,创建一个仓库。"></a>10. 点击Create repository,创建一个仓库。</h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" srcset="/img/loading.gif" lazyload alt="image-20231223190413902"></p><h1 id="11-跳转到该页面-进行如下操作。"><a href="#11-跳转到该页面-进行如下操作。" class="headerlink" title="11. 跳转到该页面,进行如下操作。  "></a>11. 跳转到该页面,进行如下操作。  <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E4%BB%93%E5%BA%93%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="image-20231223191625946"></h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E4%BB%93%E5%BA%93%E8%AE%BE%E7%BD%AE2.png" srcset="/img/loading.gif" lazyload alt="image-20231223191219671"></p><h1 id="12-出现这个页面表示新建仓库成功。"><a href="#12-出现这个页面表示新建仓库成功。" class="headerlink" title="12. 出现这个页面表示新建仓库成功。"></a>12. 出现这个页面表示新建仓库成功。</h1><p>   <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" lazyload alt="image-20231223192010300"></p><h1 id="13-点击右上角的202312232046496-png头像，单击一下会有该页面出现，再次点击其中的Settings"><a href="#13-点击右上角的202312232046496-png头像，单击一下会有该页面出现，再次点击其中的Settings" class="headerlink" title="13. 点击右上角的202312232046496.png头像，单击一下会有该页面出现，再次点击其中的Settings"></a>13. 点击右上角的202312232046496.png头像，单击一下会有该页面出现，再次点击其中的<code>Settings</code></h1><p>​      <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E5%8F%B3%E4%B8%8A%E8%A7%92settings.png" srcset="/img/loading.gif" lazyload alt="image-20231223192203114"></p><h1 id="14-出现该页面后，下划找到Developer-settings。"><a href="#14-出现该页面后，下划找到Developer-settings。" class="headerlink" title="14. 出现该页面后，下划找到Developer settings。 "></a>14. 出现该页面后，下划找到<code>Developer settings</code>。 <img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/Developer%20settings.png" srcset="/img/loading.gif" lazyload alt="image-20231223192554725"></h1><h1 id="15-进入下一个页面点击Personal-access-tokens后的-找到下拉列表中的Tokens-classic-并点击它。"><a href="#15-进入下一个页面点击Personal-access-tokens后的-找到下拉列表中的Tokens-classic-并点击它。" class="headerlink" title="15. 进入下一个页面点击Personal access tokens后的^ 找到下拉列表中的Tokens (classic)并点击它。"></a>15. 进入下一个页面点击<code>Personal access tokens</code>后的^ 找到下拉列表中的<code>Tokens (classic)</code>并点击它。<img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/Tokens%20(classic).png" srcset="/img/loading.gif" lazyload alt="image-20231223193411591"></h1><h1 id="16-在新的页面中单击Generate-new-token生成一个新的GitHub-Token"><a href="#16-在新的页面中单击Generate-new-token生成一个新的GitHub-Token" class="headerlink" title="16. 在新的页面中单击Generate new token生成一个新的GitHub Token"></a>16. 在新的页面中单击<code>Generate new token</code>生成一个新的GitHub Token<img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/Generate%20new%20token.png" srcset="/img/loading.gif" lazyload alt="image-20231223193717763"></h1><h1 id="17-我们选择下面的这种Token"><a href="#17-我们选择下面的这种Token" class="headerlink" title="17. 我们选择下面的这种Token"></a>17. 我们选择下面的这种Token<img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/new%20Token.png" srcset="/img/loading.gif" lazyload alt="image-20231223193847652"></h1><h1 id="18-Token进行如下的设置"><a href="#18-Token进行如下的设置" class="headerlink" title="18. Token进行如下的设置"></a>18. Token进行如下的设置</h1><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E8%AE%BE%E7%BD%AEToken.png" srcset="/img/loading.gif" lazyload alt="image-20231223194658727"></p><h1 id="19-保存Token"><a href="#19-保存Token" class="headerlink" title="19.保存Token"></a>19.保存Token<img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E4%BF%9D%E5%AD%98Token.png" srcset="/img/loading.gif" lazyload alt="image-20231223195022124"></h1><h1 id="20-下载并安装PicGo"><a href="#20-下载并安装PicGo" class="headerlink" title="20. 下载并安装PicGo"></a>20. 下载并安装PicGo</h1><p><a href="https://github.com/Molunerfinn/PicGo/releases">下载地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/PicGo%E7%9A%84%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5.png" srcset="/img/loading.gif" lazyload alt="image-20231223195457252"></p><h1 id="21-安装完后会有该页面出现"><a href="#21-安装完后会有该页面出现" class="headerlink" title="21. 安装完后会有该页面出现"></a>21. 安装完后会有该页面出现</h1><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/PicGo%E7%9A%84%E4%B8%BB%E7%95%8C%E9%9D%A2.png" srcset="/img/loading.gif" lazyload alt="image-20231223195733964"></p><h1 id="22-单击图床设置-找到并点击GitHub"><a href="#22-单击图床设置-找到并点击GitHub" class="headerlink" title="22.  单击图床设置 找到并点击GitHub"></a>22.  单击<code>图床设置</code> 找到并点击<code>GitHub</code></h1><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E5%9B%BE%E5%BA%8A.png" srcset="/img/loading.gif" lazyload alt="image-20231223195906571"></p><h1 id="23-进行如下的配置并确认。"><a href="#23-进行如下的配置并确认。" class="headerlink" title="23. 进行如下的配置并确认。"></a>23. 进行如下的配置并确认。</h1><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/GitHub%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="image-20231223200234673"></p><blockquote><p>使用GitHub仓库作为 图床，存在的问题是国内访问github的速度很慢，可以利用 jsDelivr CDN 来加速访问。jsDelivr 是一个免费开源的CDN 解决方案，该平台是首个打通中国大陆与海外的免费CDN服务，拥有中国政府颁发的 ICP 许可证，无须担心中国防火墙问题而影响使用。使用jsDelivr加速访问，需要将<strong>自定义域名设置为<a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D/@main%E3%80%82">https://cdn.jsdelivr.net/gh/用户名/图床仓库名/@main。</a></strong></p></blockquote><h1 id="24-测试图床功能"><a href="#24-测试图床功能" class="headerlink" title="24. 测试图床功能"></a>24. 测试图床功能</h1><p>返回上传区，上传一张图片试试</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0.png" srcset="/img/loading.gif" lazyload alt="image-20231223200614775"></p><p><strong>上传成功的话，相册里面就会有相应的图片啦，同时在GitHub仓库中也可以看到上传的图片。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E6%9C%AC%E5%9C%B0%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87.png" srcset="/img/loading.gif" lazyload alt="image-20231223200757142"></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/GitHub%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87.png" srcset="/img/loading.gif" lazyload alt="image-20231223200859757"></p><h1 id="25-图床功能使用"><a href="#25-图床功能使用" class="headerlink" title="25. 图床功能使用"></a>25. 图床功能使用</h1><p>单击按钮复制图片的url地址，在你想要插入图片的地方粘贴即可。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/%E5%9B%BE%E5%BA%8A%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8.png" srcset="/img/loading.gif" lazyload alt="image-20231223201227623"></p><p>到此为止就结束了。相信你已经有了自己的图床。✌✌✌</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习</title>
    <link href="/2023/12/23/Docker%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/12/23/Docker%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><h1 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1. Docker简介"></a>1. Docker简介</h1><p>Docker是一个用于构建 运行 传送 应用程序的平台</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231631726.png" srcset="/img/loading.gif" lazyload alt="image-20231223112004969"></p><p><strong>为什么要使用Docker</strong></p><p>一般在初学阶段可能会有以下步骤。看起来比较繁琐。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231632924.png" srcset="/img/loading.gif" lazyload alt="image-20231223112153602"></p><p>而有了Docker后，我们可以将它们打包成一个个的集装箱，只要在开发环境中运行成功，那么在其他环境一定也是可以成功的。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633844.png" srcset="/img/loading.gif" lazyload alt="image-20231223112235670"></p><h1 id="2-Docker和虚拟机的区别"><a href="#2-Docker和虚拟机的区别" class="headerlink" title="2. Docker和虚拟机的区别"></a>2. Docker和虚拟机的区别</h1><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231644492.png" srcset="/img/loading.gif" lazyload alt="image-20231223113255976"></p><p>上述的传统虚拟机是通过一种叫做虚拟化(Hypervisor)技术来实现的</p><p>虚拟化计算是一种将物理资源虚拟为多个逻辑资源的技术，它可以将一台物理服务器虚拟成多个逻辑服务器，每个逻辑服务器都有自己的操作系统、CPU 、内存、硬盘和网络接口等等。它们之间是完全隔离的，可以独立运行，虚拟机在一定程度上实现了资源的整合，可以将一台服务器的计算能力、存储能力、网络资源分配给多个逻辑服务器，实现多台服务器的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633981.png" srcset="/img/loading.gif" lazyload alt="image-20231223113632203"></p><p><strong>缺点是每台服务器都需要占用大量的资源</strong>,比如CPU、内存 、硬盘、网络等等，而且启动速度特别慢，通常需要几分钟和几十分钟，而大部分情况下，其实我们的一台服务器上只需要运行一个主要对外提供的服务的应用程序就可以了，并不需要一个完整的操作系统所提供的所有功能。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633963.png" srcset="/img/loading.gif" lazyload alt="image-20231223113855986"></p><p>了解虚拟机后，一起了解一下容器。Docker和容器是两个不同的概念。</p><p>Docker只是容器的一种实现，是一个容器化的解决方案和平台。而容器是一种虚拟化技术和虚拟机类似，也是一个独立的环境，可以在这个环境中运行应用程序，和虚拟机不同的是，它并不需要在容器中运行一个完整的操作系统，而是使用宿主机的操作系统，所以启动速度非常快。通常需要几秒钟，同时因为需要的资源更少，所以可以在一台物理服务器上，运行更多的容器，这样就可以充分利用服务器的资源，减少资源的闲置和浪费。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633642.png" srcset="/img/loading.gif" lazyload alt="image-20231223114714972"></p><h1 id="3-Docker的基本原理和概念"><a href="#3-Docker的基本原理和概念" class="headerlink" title="3. Docker的基本原理和概念"></a>3. Docker的基本原理和概念</h1><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633659.png" srcset="/img/loading.gif" lazyload alt="image-20231223114840312"></p><p>Docker是使用Client-Server架构模式，Docker Client和Docker Daemon之间是通过Socket或者RESTful API进行通信；Docker Daemon就是服务器端的守护进程，他负责管理Docker的各种资源。Diocker Client负责像Docker Daemon发送请求，Docker Daemon接受请求之后进行处理，然后将结果返回给Docker Client，Docker Daemon是一个后台进程，用来接受并处理来自Docker客户端的请求，然后将结果返回客户端，所以我们在终端输入的各种Docker命令，实际上是通过Docker客户端，发送给Docker Daemon的，然后Docker Daemon再进行处理，最后再将结果返回客户端。然后就可以在终端中看到执行结果了。</p><p><strong>Docker中的镜像、容器和仓库</strong></p><ul><li><p>镜像是一个只读的模板，它可以用来创建Docker容器。  </p></li><li><p>容器是Docker的运行示例，它提供了一个独立的可移植的环境，可以在这个环境中运行应用程序。 </p></li><li><p>镜像和容器的关系有的像Java中类和实例的关系一样，我们可以定义一个类中，有哪些属性和方法。这个定义好的类就是一个模板，然后我们可以根据这个模板来创建多个实例，这个实例就是这个类的对象。</p></li><li><p>从生活的角度看待，镜像就像是一个食谱，详细地描述如何去制作一道菜肴，而容器是你根据这个食谱做出很多道菜 ，但是做出来的菜都是一样的，而且你也可以把食谱分享给其他喜欢美食的朋友。，那他也可根据食谱，做出一样的菜。</p></li><li><p>Docker仓库是用来存储Docker镜像的地方。最流行和最常用的仓库是DockerHub，它是一个公共的Docker仓库，用来集中存储和管理Docker镜像，我们可以下载镜像以及上传自己的镜像。这样就可以实现Docker的共享和复用。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231644511.png" srcset="/img/loading.gif" lazyload alt="image-20231223164408456"></p><h1 id="4-Docker的安装配置"><a href="#4-Docker的安装配置" class="headerlink" title="4. Docker的安装配置"></a>4. Docker的安装配置</h1><p>官网安装Docker Desktop</p><p><strong>Windows端需要开启Hyper功能。</strong></p><p>Hyper-V是Windows专业版专属功能，但大多数（除商业本）品牌机内置的Windows都是家庭版。只能通过命令开启，方法如下：</p><h2 id="一、安装Hyper-V"><a href="#一、安装Hyper-V" class="headerlink" title="一、安装Hyper-V"></a>一、安装Hyper-V</h2><p>a.在桌面空白处右键-新建-文本文档，命名为 hyper-v.cmd，如图1-1</p><p>（提示：必须开启显示文件扩展名选项，否则无效，开启方法参考图1-2）</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633605.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>1-1</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633206.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>1-2</p><p>b.单击这个文件，右键-编辑，如图1-3</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231654009.png" srcset="/img/loading.gif" lazyload alt="image-20231223165440964"></p><p>1-3</p><p>c.输入以下代码，如图1-4</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">pushd</span> <span class="hljs-string">&quot;%~dp0&quot;</span><br><span class="hljs-built_in">dir</span> /b %SystemRoot%\servicing\Packages\*Hyper<span class="hljs-literal">-V</span>*.mum &gt;hyper<span class="hljs-literal">-v</span>.txt<br><span class="hljs-keyword">for</span> /f %%i <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;</span>) <span class="hljs-keyword">do</span> dism /online /norestart /<span class="hljs-built_in">add-package</span>:<span class="hljs-string">&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="hljs-built_in">del</span> hyper<span class="hljs-literal">-v</span>.txt<br>Dism /online /<span class="hljs-built_in">enable-feature</span> /featurename:Microsoft<span class="hljs-literal">-Hyper-V-All</span> /LimitAccess /ALL<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633109.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>1-4</p><p>d.点击文件-保存，如图1-5</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231655683.png" srcset="/img/loading.gif" lazyload alt="image-20231223165546650"></p><p>1-5</p><p>e.单击这个文本文档，右键-以管理员权限运行，如图1-6</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633787.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>1-6</p><p>f.等待加载完成即可，成功安装后，输入y并回车即可</p><h2 id="二、启用Hyper-V"><a href="#二、启用Hyper-V" class="headerlink" title="二、启用Hyper-V"></a>二、启用Hyper-V</h2><p>a.点击搜索按钮，输入控制面板，并点击打开，如图2-1</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231633715.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>2-1</p><p>b.点击程序与功能，如图2-2</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231640892.png" srcset="/img/loading.gif" lazyload alt="image-20231223164004798"></p><p>2-2</p><p>c.点击启用或关闭Windows功能，如图2-3</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231634917.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>2-3</p><p>d.勾选Hyper-V，Windows虚拟机监控程序平台和虚拟机平台，如图2-4，2-5</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231634091.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>2-4</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231640023.png" srcset="/img/loading.gif" lazyload alt="image-20231223164058987"></p><p>2-5</p><p>e.点击确定，如图2-6</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231634778.webp" srcset="/img/loading.gif" lazyload alt="img"></p><p>2-6</p><p>f.点击不重新启动即可</p><h1 id="5-容器化和Dockerfile"><a href="#5-容器化和Dockerfile" class="headerlink" title="5. 容器化和Dockerfile"></a>5. 容器化和Dockerfile</h1><p>容器化就是将应用程序打包成容器，然后在容器中运行应用程序的过程。这个过程可以分为三个步骤</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231646319.png" srcset="/img/loading.gif" lazyload alt="image-20231223164601276"></p><p>Dockerfile是一个文本文件，里面包含了一条条的指令，用来告诉Docker如何来构建镜像。这个文件包括了我们应用程序执行的所有命令也就是我们刚刚提到的各种依赖 配置环境和运行应用程序所需要的所有内容，一般来说包括下面这些内容：</p><ul><li><p>精简的操作系统如:Alpine</p></li><li><p>应用程序的运行环境如: Node JS  Java</p></li><li><p>应用程序 如: SpringBoot打包好的jar包  </p></li><li><p>应用程序的第三方依赖库或者包  </p></li><li><p>应用程序的配置文件、环境变量等等。</p></li></ul><p>一般我们在项目的根目录下创建一个Dockerfile文件。Docker会根据Dockerfile里面的指令来构建一个镜像，有了镜像之后，我们可以使用这个镜像来创建容器，然后在容器中运行应用程序。</p><h1 id="6-实践"><a href="#6-实践" class="headerlink" title="6. 实践"></a>6. 实践</h1><ol><li><p>首先在创建一个HelloDocker的文件夹。</p></li><li><p>然后使用任何编辑器(如Vscode)打开该文件夹。</p></li><li><p>在文件夹中创建一个index.js文件，输入console.log(“Hello, Docker”)。</p></li><li><p>再打开终端 输入 node index.js，终端会显示Hello，Docker</p></li><li><p>NodeJS是一个运行时环境，它可以让我们在浏览器之外的地方运行JavaScript的代码，NodeJS和JavaScript的关系就行Java和JRE一样。<img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231647662.png" srcset="/img/loading.gif" lazyload alt="image-20231223164753609"></p></li><li><p>所以如果我们要在另外一个环境运行程序，需要做到以下步骤:</p><ol><li>安装操作系统  </li><li>安装JavaScript运行环境(NodeJS)</li><li>复制应用程序、依赖包、配置文件</li><li>执行启动命令运行程序</li></ol></li></ol><p>有了Docker之后，我们把这些步骤写入Dockerfile中，剩下的工作Docker会自动化完成。</p><p>Dockerfile中</p><ul><li>我们需要先指定一个基础镜像，镜像是按层次来构建的，每一次都是基于上一层的，所以我们要指定一个基础镜像，然后在这个镜像的基础上添加我们的应用程序。</li><li>我们可以从linux镜像开始，然后在这个镜像基础上安装NodeJS和我们的应用程序。或者使用NodeJS镜像。添加如下代码</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">FROM node:14-alpine<br>COPY index.js /index.js <br>CMD node /index.js<br></code></pre></td></tr></table></figure><blockquote><p><code>docker build -t  hello-docker . </code> </p><p>&#x2F;&#x2F;生成一个镜像名称是hello-docker的镜像  . 表示当前目录</p></blockquote><p>运行结果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231650471.png" srcset="/img/loading.gif" lazyload alt="image-20231223133401797"></p><blockquote><p><code>docker image ls</code>  &#x2F;&#x2F; 查看docker镜像</p></blockquote><p>运行结果如下:<img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231650538.png" srcset="/img/loading.gif" lazyload alt="image-20231223165004499"></p><blockquote><p>不指定版本默认是latest，如果想要指定版本，那么可以在镜像名字后面加上冒号和版本号，这样我们就完成了镜像的构建。 </p></blockquote><blockquote><p><code>docker run hello-docker</code> &#x2F;&#x2F;运行镜像  </p></blockquote><p>运行结果如下:<img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231650202.png" srcset="/img/loading.gif" lazyload alt="image-20231223133322516"></p><p>如果你想要在另外一个环境中运行这个应用程序的话，那么就只需要复制该镜像运行以下就可以了，或者上传到DockerHub&#x2F;Harbor镜像仓库中。</p><p>同时我们也可以通过在线网页进行Docker使用</p><p><a href="%5Blabs.play-with-docker.com%5D(https://labs.play-with-docker.com/)">play-with-docker</a></p><h1 id="7-DockerDesktopd的使用"><a href="#7-DockerDesktopd的使用" class="headerlink" title="7.DockerDesktopd的使用"></a>7.DockerDesktopd的使用</h1><p>DOckerDesktop封装了容器日常使用和管理的各种常用功能，打开控制面板后，在左上角的可以看到</p><ul><li><p><strong>Containers(容器)</strong></p></li><li><p>mages(镜像)</p></li></ul><p>在这里可以看到容器和镜像的各种状态</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231635302.png" srcset="/img/loading.gif" lazyload alt="image-20231223134651306"></p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231635258.png" srcset="/img/loading.gif" lazyload alt="image-20231223134906248"></p><ul><li><p><strong>volumes(逻辑卷)</strong></p><ul><li>逻辑卷是Docker中用来存储数据的。  </li><li>Docker容器有个特点： 容器中的数据不会用永久化。  </li><li>如果为了保存容器中的数据，那么就要使用逻辑卷解决这个问题。它可以把容器中的目录&#x2F;路径映射到宿主机的某一个目录或位置上。这样就可以将数据保存到宿主机的磁盘上。实现了数据的持久化。</li></ul></li><li><p><strong>Dev Environments (开发环境)</strong>  </p><ul><li>我们可以使用一些代码来配置这个开发环境，这样就可以把这个开发环境共享给其他工作人员，这样就可以使得每个人在一个相同的环境下进行开发，避免因为环境的不一致导致的各种问题。</li></ul></li><li><p><strong>learning Center(学习中心)</strong></p></li><li><p><strong>Add Extensions(添加扩展)</strong></p></li></ul><h1 id="8-Docker-Compose"><a href="#8-Docker-Compose" class="headerlink" title="8. Docker Compose"></a>8. Docker Compose</h1><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231635589.png" srcset="/img/loading.gif" lazyload alt="image-20231223140103433"></p><p>可以通过一个单独的docker-compose。yaml的配置文件来将这一组相互关联的容器组合在一起形成一个项目，然后使用一条命令就可以启动、停止、或者重建这些服务。</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231636087.png" srcset="/img/loading.gif" lazyload alt="image-20231223140301420"></p><p>运行一下<strong>docker compose up</strong>  就可以自动安装各种依赖和配置环境，就可以在本地运行项目了。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一小时Git教程</title>
    <link href="/2023/12/22/%E4%B8%80%E5%B0%8F%E6%97%B6Git%E6%95%99%E7%A8%8B/"/>
    <url>/2023/12/22/%E4%B8%80%E5%B0%8F%E6%97%B6Git%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一小时Git教程"><a href="#一小时Git教程" class="headerlink" title="一小时Git教程"></a><a href="https://www.bilibili.com/video/BV1HM411377j/?spm_id_from=333.999.0.0">一小时Git教程</a></h1><h1 id="安装和初始化配置"><a href="#安装和初始化配置" class="headerlink" title="安装和初始化配置"></a>安装和初始化配置</h1><p>官网下载安装即可，安装完成后要验证是否安装成功，可以使用<code>git -v</code>来进行查看</p><h1 id="1-Git的使用方式"><a href="#1-Git的使用方式" class="headerlink" title="1. Git的使用方式"></a>1. Git的使用方式</h1><ul><li>命令行</li><li>图形化界面（GUI）</li><li>IDEA插件&#x2F;扩展</li></ul><h1 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2.初始化配置"></a>2.初始化配置</h1><h2 id="2-1-配置用户名和邮箱"><a href="#2-1-配置用户名和邮箱" class="headerlink" title="2.1 配置用户名和邮箱"></a>2.1 配置用户名和邮箱</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;yyyks5836&quot;<br>git config --global user.email &quot;yyyks5836@outlook.com&quot;<br></code></pre></td></tr></table></figure><ul><li>—global：全局配置，设置时对所有仓库都有效  —system：系统配置，对系统中的所有用户都有效。</li></ul><blockquote><p>如果不添加该选项，默认只对本地仓库有效,配置完成后，如果不想每次都输入用户名和密码，可以使用以下的命令进行保存个人配置</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global credential.helper store<br></code></pre></td></tr></table></figure><h2 id="2-2-查看配置的信息"><a href="#2-2-查看配置的信息" class="headerlink" title="2.2 查看配置的信息"></a>2.2 查看配置的信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global --list<br></code></pre></td></tr></table></figure><h1 id="3-创建仓库"><a href="#3-创建仓库" class="headerlink" title="3. 创建仓库"></a>3. 创建仓库</h1><ul><li>方式一：git init   <project-name>    （创建⼀个新的本地仓库（省略project-name则在当前⽬录创建）</project-name></li><li>方式二：git clone <url>      （克隆⼀个远程仓库）</url></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br>git init learn-git<br>ls<br>ls -a<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/geekhall-laoyang/remote-repo.git<br></code></pre></td></tr></table></figure><blockquote><p>在当前看到.git(隐藏文件夹)说明仓库已经创建成功了</p></blockquote><h1 id="4-工作区域和文件状态"><a href="#4-工作区域和文件状态" class="headerlink" title="4 .工作区域和文件状态"></a>4 .工作区域和文件状态</h1><h2 id="Git的本地数据管理分为三个区域"><a href="#Git的本地数据管理分为三个区域" class="headerlink" title="Git的本地数据管理分为三个区域"></a>Git的本地数据管理分为<strong>三个区域</strong></h2><ul><li><strong>工作区</strong>（Working Directory）：电脑中的文件夹</li><li><strong>暂存区</strong>（Staging Area&#x2F;Index）：临时存储区域，用于保存即将提交到Git仓库的修改内容</li><li><strong>本地仓库</strong>（Local Repository）：git init创建的那个仓库，包含了完整的项目历史和元数据</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/b20de35a8a90defe3bdbecbe415fd11.png" srcset="/img/loading.gif" lazyload></p><h2 id="Git中文件的状态"><a href="#Git中文件的状态" class="headerlink" title="Git中文件的状态"></a>Git中<strong>文件的状态</strong></h2><ul><li><strong>未跟踪</strong>（Untrack）：新创建的，还没有被Git管理起来的文件</li><li><strong>未修改</strong>（Unmodified）：已经被Git管理起来，但是文件的内容没有发生变化，还没有被修改过</li><li><strong>已修改</strong>（Modified）：已经修改了的文件，但是还没有添加到暂存区里面</li><li><strong>已暂存</strong>（Staged）：修改之后，并且已经添加到了暂存区域内的文件</li></ul><p>具体的流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/236e4555e865a518a4d75a160cc1aa5.png" srcset="/img/loading.gif" lazyload></p><h1 id="5-添加和提交文件"><a href="#5-添加和提交文件" class="headerlink" title="5 .添加和提交文件"></a>5 .添加和提交文件</h1><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init    // 创建仓库<br>git status  // 查看仓库的状态 查看当前仓库处在哪个分支，有哪些文件以及这些文件当前处在怎样的一个状态<br>git add     // 添加到暂存区<br>git commit  // 提交 只会提交暂存区中的文件，而不会提交工作区中的其他文件<br>git log     // 查看提交记录<br>git log --oneline   // 查看简洁的提交记录<br></code></pre></td></tr></table></figure><p>下面进行演示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;这是第一个文件&quot;&gt; file1.txt<br>git status<br>git add file1.txt<br>git rm --cached file1.txt   // 取消提交暂存<br>git commit -m &quot;这里输入提交的相关信息&quot;<br>git status<br></code></pre></td></tr></table></figure><h2 id="Git支持通配符添加多个文件"><a href="#Git支持通配符添加多个文件" class="headerlink" title="Git支持通配符添加多个文件"></a>Git支持通配符添加多个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add *.txt // 把当前文件夹下的所有以.txt结尾的文件都添加到暂存区<br>git add .     // 把当前文件夹下的所有的文件都添加到暂存区<br>git log<br></code></pre></td></tr></table></figure><h1 id="6-git-reset回退版本"><a href="#6-git-reset回退版本" class="headerlink" title="6. git reset回退版本"></a>6. git reset回退版本</h1><h2 id="git-reset的三种模式"><a href="#git-reset的三种模式" class="headerlink" title="git reset的三种模式"></a>git reset的三种模式</h2><ul><li><strong>soft</strong>：回退到某一个版本，并且保留工作区和暂存区的所有修改内容</li><li><strong>hard</strong>：回退到某一个版本，并且丢弃工作区和暂存区的所有修改内容</li><li><strong>mixed</strong>：回退到某一个版本，并且只保留工作区的修改内容、丢弃暂存区的修改内容<strong>（默认参数）</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/a55ac49fd03472a929c479cfdcaecaa.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --soft<br>git reset --hard<br>git reset --mixed<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">首先需要查询提交历史<br>git log --oneline<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">id</span> 相关信息</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">id</span> 相关信息</span><br>git reset --soft id<br>git log --oneline<br>git reset --hard HEAD^  // HEAD^表示上一个版本<br>git log --oneline<br>git reset HEAR^<br>git log --oneline<br></code></pre></td></tr></table></figure><blockquote><p>一般来说，当我们提交了多个版本，但是又觉得这些提交没有太大意义，可以合并成一个版本的时候，可以通过这两个参数来进行回退之后再重新提交，他们的主要区别是在重新提交之前，混合模式需要执行一下git add操作来将变动的内容重新添加到暂存区，而soft模式就不需要了，因为暂存区并没有被清空。<br>而hard参数的使用场景，则一般是真的要放弃目前本地的所有修改内容的时候，谨慎使用hard这个参数<br>如果误操作删除了，可以查询历史版本号再回退到这个版本</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reflog  // 查看我们操作的历史记录<br>git reset 版本号<br></code></pre></td></tr></table></figure><h1 id="7-使用git-diff查看差异"><a href="#7-使用git-diff查看差异" class="headerlink" title="7 .使用git diff查看差异"></a>7 .使用git diff查看差异</h1><blockquote><p><strong>git diff</strong>     &#x2F;&#x2F; 查看文件在工作区、暂存区以及版本库之间的差异 或者 查询文件在两个特定版本之间的差异  或者文件在两个分支之间的差异</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/cd6c459ae851e414995181512285a2c.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff        // 默认比较 工作区 和 暂存区 之间的差异内容，会显示发生更改的文件以及更改的详细信息<br>git diff HEAD   // 比较 工作区 和 本地仓库 之间的差异<br>git diff --cached   // 比较暂存区 和 本地仓库 之间的差异<br>git diff id1 id2    // 比较两个版本之间的差异<br>git diff id HEAD    // 比较id和当前分支之间的差异<br>git diff HEAD～ HEAD // 比较当前版本和上一个版本之间的差异<br>git diff HEAD～3 HEAD file3.txt  // 查看HEAD之前的3个版本和当前版本中 file3.txt文件中差异<br></code></pre></td></tr></table></figure><p>注：<code>HEAD</code>表示当前分支的最新提交、<code>HEAD~</code>和<code>HEAD^</code>表示上一个版本、<code>HEAD~2</code>表示HEAD之前的两个版本，数字以此类推。</p><h1 id="8-使用git-rm删除文件"><a href="#8-使用git-rm删除文件" class="headerlink" title="8 .使用git rm删除文件"></a>8 .使用git rm删除文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 方法一：<br>rm file1.txt        // 在本地工作区中删除文件<br>git ls-files        // 查看暂存区中的内容<br>git add file1.txt   // 将暂存区中的文件也删除掉<br>git add .<br>git commit -m &quot;delete file1.txt&quot;<br>// 方法二：<br>git rm file2.txt        // 将file2.txt文件在工作区和暂存区中都删除<br>git status<br>git commit -m &quot;delete file2.txt&quot;<br></code></pre></td></tr></table></figure><p>总结：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm file; git add file   // 先从工作区删除文件，然后再从暂存区删除文件<br>git rm &lt;file&gt;           // 把文件从工作区和暂存区同时删除<br>git rm --cached &lt;file&gt;  // 把文件从暂存区删除，但保留在当前工作区中<br>git rm -r *             // 递归删除某个目录下的所有子目录和文件<br>                        // 删除后不要忘记提交<br></code></pre></td></tr></table></figure><h1 id="9-gitignore忽略文件"><a href="#9-gitignore忽略文件" class="headerlink" title="9 .gitignore忽略文件"></a>9 .gitignore忽略文件</h1><p>.gitignore文件作用：让我们忽略掉一些不应该被加入到版本库中的文件，这样可以让我们的仓库体积更小、更加干净。<br>应该忽略哪些文件呢？</p><ul><li>系统或者软件自动生成的文件</li><li>编译产生的中间文件和结果文件</li><li>运行时生成日志文件、缓存文件、临时文件</li><li>涉及身份、密码、口令、密钥等敏感信息文件</li></ul><p>下面是一个实际的例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;some log&quot; &gt; access.log        // 模拟日志文件<br>echo &quot;other log&quot; &gt; other.log        // 用于对比的日志文件<br>git status    // 查看文件状态<br>echo access.log &gt; .gitignore    // 将access.log 添加到 .gitignore 文件中<br>cat .gitignore    // 查看.gitignore文件<br>git status    // 再次查看文件状态<br>git add .    // 把所有修改都添加到暂存区<br>git status    // 再次查看文件状态<br>git commit -m &quot;ignore file sample&quot;    // 提交修改<br>git ls-files    // 查看仓库中的文件<br>vi .gitignore    // 修改.gitignore文件<br>    access.log<br>    *.log        // 表示忽略所有的以log结尾的文件<br>echo hello &gt; hello.log    // 再添加一个日志文件<br>git status    // 查看状态<br>git commit -am &quot;test ignore log&quot;    // 再次提交<br>git ls-files    // 查看版本库中的文件<br></code></pre></td></tr></table></figure><blockquote><ul><li><p>注意：.gitignore文件生效需要有一个前提，即这个文件不能是已经被添加到版本库中的文件。如果文件已经添加到版本库中了，则需要使用git rm命令删除掉，然后再进行提交的操作</p></li><li><p>如果我们只是想把文件从版本库里面删除，而不想删除本地文件的话，就可以在后面加<code>—-cached</code>这个参数</p></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm —-cached other.log    // 将other.log文件从版本库删除，而不删除本地文件<br>git status    // 查询文件状态<br>git commit -am &quot;delete other.log&quot;    // 提交更改<br>echo &quot; some change&quot; &gt;&gt; other.log     // 更改文件内容<br>git status    // 查看文件状态<br></code></pre></td></tr></table></figure><p>.gitignore文件还可以配置文件夹的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir temp    // 创建temp文件夹<br>              // 注：如果temp文件夹是空的，则不会被纳入到版本控制中<br>              //     如果temp文件夹下有文件的话，就会被纳入到版本控制之中<br>echo &quot;hello&quot; &gt; temp/hello.txt    // 添加文件<br>git status -s    // -s short 查看简略模式<br>?? temp/         // 这里的两个问号，第一列表示是暂存区的状态<br>                 // 第二列表示是工作区的状态<br>vi .gitignore    // 添加temp文件夹的名称<br>    access.log<br>    *.log<br>    temp/        // 文件夹以斜线结尾<br>git status -s    // 再次查看文件状态<br>M .gitignore     // M表示.gitignore文件被修改过<br>git commit -am &quot;test ignore folder&quot;    // 提交修改<br>git ls-files     // 查看仓库文件内容<br></code></pre></td></tr></table></figure><p>.gitignore文件的匹配规则</p><p>从上到下逐行匹配，每一行表示一个忽略模式</p><ul><li>空行或者以#开头的行会被Git忽略。一般空行用于可读性的分隔，#一般用作注释</li><li>使用标准的Blob模式匹配，例如：<ul><li>星号*通配任意个字符</li><li>问号?匹配单个字符</li><li>中括号[]表示匹配列表中的单个字符，比如：[abc]表示a&#x2F;b&#x2F;c</li></ul></li><li>两个星号**表示匹配任意的中间目录</li><li>中括号可以使用短中线连接，比如：<ul><li>[0-9]表示任意一位数字，[a-z]表示任意一位小写字母</li></ul></li><li>感叹号!表示取反<ul><li>要忽略指令模式以外的文件或者目录可以加!</li></ul></li></ul><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有的 .a 文件</span><br>*.a<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">但跟踪所有的 lib.a ，即使你在前面忽略了 .a 文件</span><br>!lib.a<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略任何目录下名为 build 的文件夹</span><br>build/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br>doc/*.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure><p>GIT官网匹配规则：</p><p><a href="https://git-scm.com/docs/gitignore">官网地址</a><br>github提供的各种常用语言的忽略文件的模板，在新建仓库的时候，我们可以直接使用，也可以根据自己的需要进行修改，<a href="https://github.com/github/gitignore">文件地址</a></p><h1 id="10-注册GitHub账号"><a href="#10-注册GitHub账号" class="headerlink" title="10. 注册GitHub账号"></a>10. 注册GitHub账号</h1><h1 id="11-SSH配置和克隆仓库"><a href="#11-SSH配置和克隆仓库" class="headerlink" title="11 .SSH配置和克隆仓库"></a>11 .SSH配置和克隆仓库</h1><p>创建仓库步骤</p><ul><li>Create repository</li><li>填写Repository name</li><li>Description</li><li>选择可见性</li><li>是否初始化一个README文件</li><li>是否创建一个.gitignore文件</li><li>开源许可证文件</li><li>点击新建仓库按钮</li></ul><p>HTTPS模式和SSH模式：</p><ul><li>HTTPS：<ul><li>在我们把本地代码push到远程仓库的时候，需要验证用户名和密码</li><li>在2021年8月13日以后，HTTPS这种方式已被GitHub停止使用了</li></ul></li><li>SSH：<ul><li>这种方式在推送的时候不需要验证用户名和密码，但是需要在GitHub上添加SSH公钥的配置</li><li>这种是比较推荐的方式，更加安全和方便</li></ul></li></ul><p>复制地址并克隆仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:geekhall-luoyang/remote-repo.git<br></code></pre></td></tr></table></figure><p>报错了，提示我们没有正确的访问权限，是因为我们还没有配置SSH密钥导致的，下面看看如何配置SSH密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd    // 回到用户的根目录<br>cd .ssh    // 进入到.ssh目录<br>ssh-keygen -t rsa -b 4096    // -t 指定协议为RSA -b 指定生成的大小为4096<br>// 需要我们输入密钥的文件名称<br>test<br>// 再次回车生成密码<br>// 如果直接回车，默认没有密码<br>// 否则输入密码，并记住，在下面的步骤中还会用到<br>ls -ltr    // 查看本地目录<br>test       // 私钥文件，谁要也不给！！！<br>test.pub   // 公钥文件，上传到GitHub<br></code></pre></td></tr></table></figure><p>我们需要打开公钥文件，然后复制公钥文件的内容，回到GitHub页面，点击右上角的头像，找到最下面的settings，在页面左侧有<code>SSH and GPG keys</code>，点开之后点击页面右侧的<code>New SSH key</code>，然后把刚刚复制的公钥内容粘贴到下面的输入框中（即Key），Title输入任意的名字（这里输入test），然后点击<code>Add SSH key</code>添加这个密钥，就成功的把密钥添加到GitHub上了。</p><p>创建config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">github</span><br>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/git_test<br></code></pre></td></tr></table></figure><p>该文件的意思是当我们访问github.com的时候，指定使用SSH下的test这个密钥。<br>然后回到本地仓库再次执行克隆命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:geekhall-luoyang/remote-repo.git<br>// 这里提示我们要输入密码，也就是我们刚刚创建SSH密钥的时候指定输入的密码<br>// 如果当时直接回车，这里也直接回车<br>// 否则输入密码<br>// 克隆成功后，进入仓库<br>cd remote-repo<br>echo hello &gt; hello.txt    // 添加文件<br>git add .    // 添加到暂存区<br>git commit -m &quot;first commit&quot;    // 提交到本地仓库<br>git ls-files    // 查看仓库状态<br></code></pre></td></tr></table></figure><p>管理本地仓库和远程仓库</p><ul><li>git pull<ul><li>把远程仓库的修改拉取到本地仓库</li></ul></li><li>git push<ul><li>把本地仓库的修改推送给远程仓库</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push    // 把本地仓库的修改推送给远程仓库<br></code></pre></td></tr></table></figure><p>总结</p><ul><li>生成SSH Key<ul><li>ssh-keygen -t rsa -b 4096<ul><li>私钥文件：id-rsa</li><li>公钥文件：id-rsa.pub</li></ul></li></ul></li><li>克隆仓库<ul><li>git clone repo-address</li></ul></li><li>推送更新内容<ul><li>git push &lt;remote&gt; &lt;branch&gt;</li></ul></li><li>拉取更新内容<ul><li>git pull &lt;remote&gt;</li></ul></li></ul><h1 id="12-关联本地仓库和远程仓库"><a href="#12-关联本地仓库和远程仓库" class="headerlink" title="12 .关联本地仓库和远程仓库"></a>12 .关联本地仓库和远程仓库</h1><p>如果我们本地已经有了一个仓库，怎样才能把它放到远程仓库里面呢？</p><blockquote><p>首先在github上创建一个新的仓库，名称为：first-repo，直接点击创建仓库按钮<br>点击url右侧的按钮来复制一下地址,现在我们的目标是将本地仓库my-repo和first-repo仓库关联起来</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin git@github.com:geekhall-laoyang/first-repo.git<br>// 添加一个远程仓库<br>// origin：远程仓库的别名，一般默认的别名都是这个，也可以自己指定一个其他的名字<br>git remote -v    // 查看我们的当前仓库所对应的远程仓库的别名和地址<br>git branch -M main    // 指定分支的名称为main<br>git push -u origin main    // 把本地的main分支和远程仓库的main分支关联起来<br>git push -u origin main:main    // 上面命令的全称<br>    // -u upstream 把本地仓库和别名为origin的远程仓库关联起来<br>    // main:main 把本地仓库的main分支推送给远程仓库的main分支<br>    // 如果本地分支的名称和远程仓库的名称相同的话 我们就可以省略 只写一个main就可以了<br>// 回车之后会提示我们输入密码<br></code></pre></td></tr></table></figure><p>将远程仓库的文件拉取到本地仓库<br>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>这里面仓库到名称和分支的名称可以省略，如果省略到话默认就是拉取仓库别名为origin的main分支<br>它到作用就是把远程仓库的指定分支拉取到本地再进行合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull<br></code></pre></td></tr></table></figure><blockquote><p>注意：在执行完一次git pull之后，git会自动为我们执行一次合并操作，如果远程仓库中的修改内容和本地仓库中的修改内容没有冲突的话，那么合并操作就会成功，否则合并操作就会由于冲突而失败，这个时候我们就需要手动来解决一下冲突</p></blockquote><blockquote><p>从远程仓库获取内容还可以使用fetch命令，fetch和pull的区别在于，fetch只是获取远程仓库的修改，但是并不会自动合并到本地仓库中，而是需要我们手动合并</p></blockquote><p>总结</p><ul><li><p>添加远程仓库：</p><p>     1. git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;<br>    2. git push -u &lt;远程仓库名&gt; &lt;分支名&gt;</p></li><li><p>查看远程仓库：</p><ul><li>git remote -v</li></ul></li><li><p>拉取远程仓库内容：</p><ul><li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</li><li>&lt;远程分支名&gt;:&lt;本地分支名&gt;如果相同可以省&lt;本地分支名&gt;</li></ul></li></ul><h1 id="13-Gitee的使用和GitLab本地化部署"><a href="#13-Gitee的使用和GitLab本地化部署" class="headerlink" title="13. Gitee的使用和GitLab本地化部署"></a>13. Gitee的使用和GitLab本地化部署</h1><p>目前用不到，以后需要再用</p><h1 id="14-GUI工具"><a href="#14-GUI工具" class="headerlink" title="14 .GUI工具"></a>14 .GUI工具</h1><ul><li>GitHub Desktop</li><li>Sourcetree</li><li>GitKraken</li></ul><h1 id="15-在VSCode中使用git"><a href="#15-在VSCode中使用git" class="headerlink" title="15 .在VSCode中使用git"></a>15 .在VSCode中使用git</h1><p>配置VSCode的命令行启动，即code .<br>点击 查看菜单栏 -&gt; 命令面板 （control shift + p）-&gt; 输入 path -&gt; 在PATH中安装code命令</p><p>在代码管理器中四个图标的作用</p><ul><li>打开文件<ul><li>在vscode中打开对应的文件</li></ul></li><li>放弃更改<ul><li>丢弃这个文件还没提交的更改内容</li></ul></li><li>添加到暂存区<ul><li>就是git add命令</li></ul></li><li>当前文件的状态<ul><li>??（Untracked）：未跟踪</li><li>U（Untracked）：未跟踪（这个讲解和上面的有出入？？？）</li><li>M（Modified）：已修改</li><li>A（Added）：已添加暂存</li><li>D（Deleted）：已删除</li><li>R（Renamed）：重命名</li><li>U（Updated）：已更新未合并</li></ul></li></ul><p>提交修改：点击提交按钮，等价于git commit -m</p><h1 id="16-分支简介和基本操作"><a href="#16-分支简介和基本操作" class="headerlink" title="16 .分支简介和基本操作"></a>16 .分支简介和基本操作</h1><p>分支的使用场景：</p><blockquote><p>分支非常适合团队协作和开发管理，比如多个开发人员可以在自己的分支上进行开发工作，最后再合并到主线代码库中，我们也可以在一个分支上进行新功能的开发，或者建立一个问题修复的分支来处理一些bug和缺陷，这样就可以让主线代码仓库处于一个随时可用的比较稳定的状态，而不会影响到其他功能的开发和测试，保证了项目的正常运行和高效协作。分支的优点就是能够提高团队协作的效率，减少冲突和错误的影响，让团队中的每个人都能独立地开发和测试。</p></blockquote><p>下面我们来一起看一下Git中分支的一些基本操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir branch-demo<br>cd branch-demo<br>git init    // 初始化仓库<br></code></pre></td></tr></table></figure><p>仓库中的文件名和提交记录我们都以最简单的方式来命名，使用分支名加序号来命名文件，使用分支名加冒号加序号的方式来编写提交记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo main1 &gt; main1.txt<br>git add .<br>git commit -m &quot;main:1&quot;    // main分支的第1次提交<br>echo main2 &gt; main2.txt<br>git commit -m &quot;main:2&quot;    // main分支的第2次提交<br>echo main3 &gt; main3.txt<br>git commit -m &quot;main:3&quot;    // main分支的第3次提交<br>git branch    // 查看当前仓库的所有分支<br>* main    // * 后面的就是目前所处的分支<br>git branch dev    // 创建新的分支，名为dev<br>git branch    // 查看当前仓库的所有分支<br>git checkout dev    // 切换到dev分支<br>// checkout 命令还有其他的功能，为了避免歧义，改用switch命令<br>git switch main    // 切换到main分支<br>git switch dev    // 切换到dev分支<br>echo dev1 &gt; dev1.txt<br>git add .<br>git commit -m &quot;dev:1&quot;<br>echo dev2 &gt; dev2.txt<br>git add .<br>git commit -m &quot;dev:2&quot;<br>git switch main<br>echo main4 &gt; main4.txt<br>git add .<br>git commit -m &quot;main:4&quot;<br>echo main5 &gt; main5.txt<br>git add .<br>git commit -m &quot;main:5&quot;<br></code></pre></td></tr></table></figure><p>现在假如测试完成，并没有任何问题之后，我们就需要把这个dev功能的分支合并到主线代码中，可以使用git merge命令来将不同的分支合并到当前分支中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge dev<br>// dev 是将要被合并的分支<br>// 当前所在的分支就是合并后的目标分支<br>// 也就是 如果把dev分支合并到main分支中<br>    // 切换到main分支<br>    // git merge dev<br></code></pre></td></tr></table></figure><p>如果想通过命令行查看分支图，可以使用git log</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --graph --online --decorate --all<br></code></pre></td></tr></table></figure><p>如果一个分支不再需要了，可以进行删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d dev    // 删除已经完成合并到分支<br>// 如果一个分支已经被合并到其他分支中了，就可以使用该命令进行删除<br>// 但如果没有被合并 则需将 -d 变为 -D 来强制删除<br>git branch<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>查看分支列表：<ul><li>git branch</li></ul></li><li>创建分支：<ul><li>git branch branch-name</li></ul></li><li>切换分支<ul><li>git checkout branch-name</li><li>git switch branch-name    （推荐）</li></ul></li><li>合并分支<ul><li>git merge branch-name</li></ul></li><li>删除分支<ul><li>已合并<ul><li>git branch -d branch-name</li></ul></li><li>未合并<ul><li>git branch -D branch-name</li></ul></li></ul></li></ul><h1 id="17-解决合并冲突"><a href="#17-解决合并冲突" class="headerlink" title="17 .解决合并冲突"></a>17 .解决合并冲突</h1><p>一般情况下，如果两个分支的修改内容没有重合的部分的话，那么合并分支就非常简单，Git会为我们自动完成合并，但是如果两个分支修改了同一个文件的同一行代码，Git就不知道应该保留哪个分支的修改内容了，也就产生了冲突，这个时候就需要我们手动来解决冲突。</p><p>首先看一个例子，沿用上节课的仓库，新建分支feat，feat是feature的缩写，一般用来表示开发某一个功能的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch feat<br>git switch feat<br>ls<br>vi main1.txt<br>  main1<br>  这是feat分支中添加的内容<br>git commit -a -m &quot;feat:1&quot;    // 加上-a参数，就可以一个命令完成 添加暂存 和 提交 两个动作<br>git switch main<br>vi main1.txt<br>  main1<br>  这是main分支中添加的内容<br>git commit -am &quot;main:6&quot;<br>// 这时，main分支和feat分支就产生了分歧<br>git merge feat    // 尝试合并分支<br>// 提示：自动合并失败了，需要解决冲突之后在提交<br>git status    // 查看冲突文件的列表<br>git diff    // 查看冲突的具体内容<br></code></pre></td></tr></table></figure><p>这时我们需要手工编辑这个文件，留下我们想要的内容之后在提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi main1.txt<br></code></pre></td></tr></table></figure><p>将文件内容由</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">main1<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>这是main分支中添加的内容<br>=======<br>这是feat分支中添加的内容<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feat<br></code></pre></td></tr></table></figure><p>修改为</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">main1<br>这是main分支中添加的内容,这是合并后的内容<br></code></pre></td></tr></table></figure><p>之后保存退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;merge conflict&quot;<br>// 提交之后就自动完成了合并<br>// 在提交之间如果想中断这次合并的话，可以使用git merger --abort 命令来终止合并<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>两个分支未修改同一个文件的同一处位置：Git自动合并</li><li>两个分支修改了同一个文件的同一处位置：产生冲突<ul><li>解决方法：<ol><li>手工修改冲突文件，合并冲突内容</li><li>添加暂存区 git add file</li><li>提交修改 git commit -m “message”</li></ol></li><li>中止合并：当不想继续执行合并操作时可以使用下面的命令来中止合并过程<ul><li>git merge –abort</li></ul></li></ul></li></ul><h1 id="18-回退和rebase"><a href="#18-回退和rebase" class="headerlink" title="18 .回退和rebase"></a>18 .回退和rebase</h1><p>除了使用merge操作来合并不同的分支，还有另外一个方法可以将不同分支的修改内容整合到一起，就是rebase，中文意思是变基</p><p>下面来看一下怎样使用rebase以及在什么情况下使用rebase</p><p>之前在执行合并操作的时候，是先使用checkout或者switch命令来切换到main分支，然后执行git merge dev命令，就可以将dev分支合并到main分支上。合并完成之后的结果就是main分支上会多出一个提交记录，然后两个分支就像两条溪流一样汇聚到了一起。</p><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/96cab327eaaef6f1f8858db9a26f7fb.png" srcset="/img/loading.gif" lazyload></p><p>那么如果使用rebase的话，就不必在main分支上执行操作了，我们可以在任意分支上执行rebase操作，可以在dev分支上，也可以在main分支上</p><p>如果我们在dev分支上执行rebase操作的话，dev分支的两次提交记录就都会变基到main分支上，而在main分支上执行的话，main分支的两次提交记录就会变基到dev分支的末尾，执行rebase之后，最后的结果都是一条直线，但是中间的顺序会稍微有些不同。</p><p>在Git中，每个分支都有一个指针，指向当前分支的最新提交记录，而在执行rebase操作的时候，Git会先找到当前分支和目标分支的共同祖先，这里也就是main3这个提交节点，再把当前分支上从共同祖先到最新提交记录的所有提交都移动到目标分支的最新提交后面</p><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/a888964b1c69b2593fe400503fa0368.png" srcset="/img/loading.gif" lazyload></p><p>下面实际演示一下rebase操作<br>首先进入到之前创建的这个branch-demo的仓库中，先将仓库恢复到执行merge之前的状态，也就是main:5这次之前的提交，现将演示合并冲突的feat分支删除掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d feat    // 删除feat分支<br></code></pre></td></tr></table></figure><p>在之前合并完成之后，我们已经把dev分支删除掉了，现在需要把它恢复回来，可以执行git checkout -b dev id，这样就可以恢复到这个分支的该时间点的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b dev 224d35<br></code></pre></td></tr></table></figure><p>这个提交ID可以在可视化工具GitKraken中看到，可以使用git log命令来查看，注意下面的操作都是在dev分支中完成的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --one line --graph --decorate --all<br></code></pre></td></tr></table></figure><p>如果命令太长了，可以使用alias命令来将它定义为一个别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias graph=&quot;git log --one line --graph --decorate --all&quot;<br></code></pre></td></tr></table></figure><p>这样就可以直接使用graph来查看图形化的提交记录了<br>然后我们再切换回main分支，因为main分支也需要退回到合并之前的main:5这次提交的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git switch main<br></code></pre></td></tr></table></figure><p>可以使用reset命令来将我们的仓库回退到某一个时间点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard b4d139<br></code></pre></td></tr></table></figure><p>这样仓库的状态就恢复到了我们执行合并操作之前的状态了<br>为了演示两次不同的rebase操作，我们先来将这个仓库复制一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>cp -rf branch-demo rebase1<br>cp -rf branch-demo rebase2<br></code></pre></td></tr></table></figure><p>下面在rebase1中执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git switch dev     // 切换到dev分支<br>git rebase main    // 将当前的dev分支变基到目标的main分支上<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/4a796e22d0a5bb58ef63bf27947e37a.png" srcset="/img/loading.gif" lazyload></p><p>下面再来看一下在main分支上执行rebase操作的结果，我们打开rebase2这个仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git switch main<br>git rebase dev    // 将当前的main分支变基到目标的dev分支上<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/29301d2b0d16ae25ece11b74add32d5.png" srcset="/img/loading.gif" lazyload></p><p>那么rebase和merge有什么区别，该如何区分使用呢？</p><ul><li>merge<ul><li>优点：不会破坏原分支的提交历史，方便回溯和查看</li><li>缺点：会产生额外的提交节点，分支图比较复杂</li></ul></li><li>rebase<ul><li>优点：不会新增额外的提交记录，形成线性历史，比较直观和干净</li><li>缺点：会改变提交历史，改变了当前分支branch out的节点，要避免在共享分支使用</li></ul></li></ul><p>一般来说，如果你只是想把两个分支合并起来，而不关心提交历史的话，那么就可以使用git merge命令，如果你确定只有你自己在一个分支上开发，并且希望提交历史更加的清晰明了，那么就建议使用rebase命令</p><h1 id="19-分支管理和工作流模型"><a href="#19-分支管理和工作流模型" class="headerlink" title="19 .分支管理和工作流模型"></a>19 .分支管理和工作流模型</h1><p>所谓工作流模型就是一些比较好的规范和流程，可以让我们的工作更高效、更有条理。<br>一个比较常用和流行的工作流模型是：GitFlow模型</p><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/024f8bae5ca7783936e23cb0ed8146c.png" srcset="/img/loading.gif" lazyload></p><p>它将分支分成了五种类型，每种类型都有自己的用途</p><ul><li>主分支（master&#x2F;main）：代表了项目的稳定版本，每个提交到主分支的代码都应该是经过测试和审核的</li><li>开发分支（develop）：用于日常开发。所有的功能分支、发布分支和修补分支都应该从开发分支派生出来</li><li>功能分支（feature）：用于开发单独的功能或者特性。每个功能分支都应该从开发分支派生，并在开发完成后合并回开发分支</li><li>发布分支（release）：用于准备项目发布。发布分支应该从开发分支派生，并在准备好发布版本后合并回主分支和开发分支</li><li>热修复分支（hotfix）：用于修复主分支上的紧急问题。热修复分支应该从主分支派生，并在修复完成后，合并回主分支和开发分支</li></ul><p>另外一个模型是GitHub Flow</p><p><img src="https://cdn.jsdelivr.net/gh/liu-moon/pic@main/img/44022fee646289028380f3f7f1372e7.png" srcset="/img/loading.gif" lazyload></p><p>GitHub Flow模型只有一个长期存在的主分支，而且主分支上的代码是可以直接部署到生产环境中的，那一般会设置分支保护，禁止团队成员直接在主分支上进行提交，团队成员可以从主分支中分离出自己的分支进行开发和测试，然后在本地分支提交代码，等到开发完成之后，可以发起一个Pull Request（简称PR、拉请求或者合并请求），团队成员们可以对代码进行Review评审，如果没有问题，就可以将这个PR发布和合并到主分支中，整个流程就完成了</p><p>还有一些比较好的习惯</p><ul><li>分支命名<ul><li>推荐使用带有意义的描述性名称来命名分支<ul><li>版本发布分支&#x2F;Tag示例：v1.0.0</li><li>功能分支示例：feature-login-page</li><li>修复分支示例：hotfix-#issueid-desc</li></ul></li></ul></li><li>分支管理<ul><li>定期合并已经成功验证的分支，及时删除已经合并的分支</li><li>保持合适的分支数量</li><li>为分支设置合适的管理权限</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法学习</title>
    <link href="/2023/12/20/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/12/20/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h1 id="Markdown标题"><a href="#Markdown标题" class="headerlink" title="Markdown标题"></a>Markdown标题</h1><ul><li><p><strong>可以使用两种标记底线(&#x3D;&#x2F;-)和#（#(1-6） +空格键 +标题内容)</strong></p></li><li><p><strong>底线是&#x3D;表示一级标题,底线是-表示二级标题且底线符合的数量至少2个</strong></p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">我展示的是一级标题</span><br><span class="hljs-section">==</span><br><br><span class="hljs-section">我展示的是二级标题</span><br><span class="hljs-section">--</span><br><br><span class="hljs-section"># 一级标题</span><br><br><span class="hljs-section">## 二级标题</span><br><br><span class="hljs-section">### 三级标题</span><br><br><span class="hljs-section">#### 四级标题</span><br><br><span class="hljs-section">##### 五级标题</span><br><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><h2 id="Markdown-标题编号"><a href="#Markdown-标题编号" class="headerlink" title="Markdown 标题编号"></a>Markdown 标题编号</h2><ul><li>Markdown处理器支持<a href="https://markdown.com.cn/basic-syntax/headings.html">标题</a>的自定义ID 添加自定义ID允许您直接链接到标题并使用CSS对其进行修改。</li><li>要添加自定义标题ID，在与标题相同的行上用大括号括起该自定义ID。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">例如:<br>### My Great Heading &#123;#custom-id&#125;<br></code></pre></td></tr></table></figure><h2 id="链接到标题ID-headid"><a href="#链接到标题ID-headid" class="headerlink" title="链接到标题ID (#headid)"></a>链接到标题ID (#headid)</h2><ul><li><p>通过创建带有数字符号（<code>#</code>）和自定义标题ID的<a href="(/basic-syntax/links.html">标准链接</a>，可以链接到文件中具有自定义ID的标题。</p></li><li><p>其他网站可以通过将自定义标题ID添加到网页的完整URL（例如<code>[Heading IDs](https://markdown.com.cn/extended-syntax/heading-ids.html#headid)</code>）来链接到标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">Heading IDs</span>](<span class="hljs-link">https://markdown.com.cn/extended-syntax/heading-ids.html#headid</span>)<br></code></pre></td></tr></table></figure></li></ul><h1 id="Markdown段落"><a href="#Markdown段落" class="headerlink" title="Markdown段落"></a>Markdown段落</h1><ul><li><p>由一行或多行文本组成,不同段落之间使用空行标记.</p></li><li><p>行与行之间没有空行,则会被认为同一段落.</p></li><li><p>空行指的是行内什么都没有,或者只有空格和制表符</p></li><li><p><strong>段落的换行是在上一行的结尾插入两个以上空格加上回车</strong>。<strong>当然也可以在段落后面使用一个空行来表示重新开始一个段落。</strong></p></li></ul><hr><h1 id="Markdown字体"><a href="#Markdown字体" class="headerlink" title="Markdown字体"></a>Markdown字体</h1><ol><li>粗体：在内容两边加入**两个(<em><strong>或</strong>下划线_</em>*_)</li></ol><p><strong>hello word</strong>   <strong>hello world</strong> </p><ol start="2"><li>斜体 ：在内容两边加入**一个(<em><strong>或</strong>下划线_</em>*  )</li></ol><p><em>hello word</em>  <em>hello world</em> </p><ol start="3"><li>斜体加粗 ：在内容两边加入**三个(<em><strong>或</strong>下划线_</em>*  )</li></ol><p><em><strong>hello word</strong></em>    </p><ol start="4"><li>标记文本: 在内容两边加上&#x3D;&#x3D;</li></ol><p> &#x3D;&#x3D;hello word&#x3D;&#x3D;    </p><ol start="5"><li>上标:在内容两边加上^</li></ol><p> x^2^</p><ol start="6"><li>下标:  在内容两边加入~</li></ol><p>0<del>2</del></p><ol start="7"><li><p>删除线：在内容两边加上两个波浪线~ 号 </p><p><del>hello</del></p></li><li><p>下划线 : 通过HTML的<u>标签来实现</u></p><p><u>带下划线文本</u></p></li></ol><h1 id="Markdown-分隔线"><a href="#Markdown-分隔线" class="headerlink" title="Markdown 分隔线"></a>Markdown 分隔线</h1><ul><li>至少三个-号 或 * 号或_来标记</li></ul><hr><hr><h1 id="Markdown脚注"><a href="#Markdown脚注" class="headerlink" title="Markdown脚注"></a>Markdown脚注</h1><ul><li>语法格式为 : [^要注明的文本内容]</li></ul><p>例：</p><p>创建脚注<a href="%E8%84%9A%E6%B3%A8%E5%86%85%E5%AE%B9">^脚注名称</a></p><hr><h1 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h1><ul><li>Markdown支持有序列表和无序列表</li></ul><ol><li>无序列表使用星号(* )、加号(+)、或者减号(-)作为列表标记，<strong>这些标记后面要添加一个空格</strong></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><p>显示的效果：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li><p>第一项</p></li><li><p>第二项</p></li><li><p>第三项</p></li></ul><ol start="2"><li>有序列表使用数字序号+英文句号+空格+列表内容来表示</li></ol>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><p>显示的效果：</p><pre><code class="hljs">1. 第一项2. 第二项3. 第三项</code></pre><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><ul><li><p>语法:为 :<br><code>- +空格+英文[ ]+内容 未勾选 </code></p><p><code>- +空格+英文[x]+内容 已勾选</code></p></li><li><p><input checked disabled type="checkbox"> Write the press release<br><strong>您可以通过单击项目前面的复选框来更改完成&#x2F;未完成状态</strong>。</p></li></ul><hr><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>列表的嵌套只需在子列表前加上一个Tab键 (减号- 和空格)</p><ol><li><p>第一项:</p><ul><li>第一项嵌套的一个元素</li><li>第一项嵌套的二个元素</li></ul></li><li><p>第二项:</p><ul><li>第二项嵌套的一个元素</li><li>第二项嵌套的二个元素</li></ul></li></ol><h1 id="Markdown-引用"><a href="#Markdown-引用" class="headerlink" title="Markdown 引用"></a>Markdown 引用</h1><p>Markdown区块引用是在段落开头使用**&gt;**符号，然后紧跟一个空格：</p><blockquote><p> 洋洋要开森    </p></blockquote><p>另外区块是可以嵌套的 一个&gt;是最外面，两个&gt;符号是第一层的嵌套：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二次嵌套</p></blockquote></blockquote></blockquote><p><strong>区块中使用列表:</strong></p><blockquote><p>区块中使用列表:</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><p><strong>列表中使用区块：</strong></p><ul><li><p>第一项</p><blockquote><p>洋洋要开森  </p></blockquote></li><li><p><strong>插入标记符号不想被符号渲染,可以使用\进行转义 语法如下:</strong></p><ul><li><p>\ 特殊符号</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">例如:<br>\ \<br>\ *<br><br>\[]<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h1><ol><li><p>行内代码: </p><p>如果是段落上的一个函数或者片段的代码可以用反引号给他包起来(&#96;),例如:</p><pre><code class="hljs">`println` 函数</code></pre></li></ol><hr><ol start="2"><li>代码区块</li></ol><p>​代码区块使用Tab键（在编辑模式下）或者4个空格开头以及使用三个&#96;或者三个~包裹一段代码</p><p>以Tab键开头: </p><pre><code class="hljs">def test_print():    pass</code></pre><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[]args)</span></span>&#123;println<span class="hljs-string">&quot;Hello,world&quot;</span>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h1><p>链接使用方法如下：</p><pre><code class="hljs">[ 链接名称](链接地址 &quot;超链接title&quot;)或者&lt;链接地址&gt;</code></pre><p>&lt;<a href="http://www.baidu.com>/">www.baidu.com&gt;</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。<br></code></pre></td></tr></table></figure><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><h2 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">在正文中引用链接标记<br><span class="hljs-selector-attr">[链接文字]</span><span class="hljs-selector-attr">[链接标记]</span><br><br>在底部中定义链接标记<br><span class="hljs-selector-attr">[链接标记]</span>: 链接地址<br></code></pre></td></tr></table></figure><p>语法说明如下:</p><ol><li>链接标记可以有字母|数|空格|标点符号.</li><li>链接标记不分大小写</li><li>链接地址为网络地址时要以http或https 开头</li></ol><p>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a></p><hr><h1 id="Markdown图片"><a href="#Markdown图片" class="headerlink" title="Markdown图片"></a>Markdown图片</h1><p>Markdown图片语法格式如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址)<br><br>!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址 &quot;图片title&quot;)<br></code></pre></td></tr></table></figure><ol><li>图片可以是本地图片的路径或者网络图片的地址</li><li>本地图片支持绝对路径和相对路径</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png)<br><br>![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png <span class="hljs-string">&quot;RUNOOB&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231624207.png" srcset="/img/loading.gif" lazyload alt="image-20231223162416144"></p><h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><p>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[![沙漠中的岩石图片](/assets/img/shiprock.jpg &quot;Shiprock&quot;)](https://markdown<br>.com.cn)<br></code></pre></td></tr></table></figure><p>当然，你也可以像网址那样对图片网址使用变量:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">这个链接用 <span class="hljs-number">1</span> 作为网址变量 [RUNOOB][<span class="hljs-number">1</span>].<br>然后在文档的结尾为变量赋值（网址）<br><br>[<span class="hljs-number">1</span>]: http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png<br></code></pre></td></tr></table></figure><p>这个链接用 1 作为网址变量 <a href="http://static.runoob.com/images/runoob-logo.png">RUNOOB</a>.<br>然后在文档的结尾为变量赋值（网址）</p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">decoding</span>=<span class="hljs-string">&quot;async&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231625113.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</p><p>语法格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>|<br>|<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>语法说明:</p><ol><li>单元格之间使用| 来分隔</li><li>单元格和|之间的空格会被移除</li><li>表头与其他行使用- 来分隔</li><li>对齐方式</li></ol><ul><li><strong>-:</strong> 设置内容和标题栏居右对齐。</li><li><strong>:-</strong> 设置内容和标题栏居左对齐。</li><li><strong>:-:</strong> 设置内容和标题栏居中对齐。</li></ul><p>实例如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><p>以上代码显示结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231627494.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><hr><h1 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h1><h2 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">使用 &lt;<span class="hljs-selector-tag">kbd</span>&gt;Ctrl&lt;/<span class="hljs-selector-tag">kbd</span>&gt;+&lt;<span class="hljs-selector-tag">kbd</span>&gt;Alt&lt;/<span class="hljs-selector-tag">kbd</span>&gt;+&lt;<span class="hljs-selector-tag">kbd</span>&gt;<span class="hljs-selector-tag">Del</span>&lt;/<span class="hljs-selector-tag">kbd</span>&gt; 重启电脑<br></code></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231627247.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**文本加粗**</span> <br>\*\* 正常显示星号 \*\*<br></code></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231627806.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\   反斜线<br>`   反引号<br><span class="hljs-bullet">*</span>   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br><span class="hljs-section">#   井字号</span><br><span class="hljs-bullet">+</span>   加号<br><span class="hljs-bullet">-</span>   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p><strong>Markdown Preview Enhanced</strong> 使用 <a href="https://github.com/Khan/KaTeX">KaTeX</a> 或者 <a href="https://github.com/mathjax/MathJax">MathJax</a> 来渲染数学表达式。</p><p>KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions&#x2F;symbols 来了解 KaTeX 支持那些符号和函数。</p><p>默认下的分隔符：</p><ul><li><code>$...$</code> 或者 <code>\(...\)</code> 中的数学表达式将会在行内显示。</li><li><code>$$...$$</code> 或者 <code>\[...\]</code> 或者 &#96;&#96;&#96;&#96;math&#96; 中的数学表达式将会在块内显示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231627144.gif" srcset="/img/loading.gif" lazyload alt="img"></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;Bmatrix&#125;<br>   a &amp; b \\<br>   c &amp; d<br>\<span class="hljs-keyword">end</span>&#123;Bmatrix&#125;<br><span class="hljs-variable">$$</span><br><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;CD&#125;<br>   A @&gt;a&gt;&gt; B \\<br><span class="hljs-variable">@VbVV</span> <span class="hljs-variable">@AAcA</span> \\<br>   C @= D<br>\<span class="hljs-keyword">end</span>&#123;CD&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://cdn.jsdelivr.net/gh/yyyks5836/hexo-images@main/images/202312231627645.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><hr><h1 id="Markdown-使用-Emoji-表情"><a href="#Markdown-使用-Emoji-表情" class="headerlink" title="Markdown 使用 Emoji 表情"></a>Markdown 使用 Emoji 表情</h1><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入<em>emoji shortcodes</em></p><h2 id="复制和粘贴表情符号"><a href="#复制和粘贴表情符号" class="headerlink" title="复制和粘贴表情符号"></a>复制和粘贴表情符号</h2><p>在大多数情况下，您可以简单地从<a href="https://emojipedia.org/">Emojipedia</a> 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。</p><p><strong>Tip:</strong> 如果您使用的是静态网站生成器，请确保将HTML页面编码为<strong>UTF-8。.</strong></p><h2 id="使用表情符号简码"><a href="#使用表情符号简码" class="headerlink" title="使用表情符号简码"></a>使用表情符号简码</h2><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">去露营了！ :tent: 很快回来。<br><br>真好笑！ :joy:<br>:smile:<br>:laughing:<br>:+1:<br>:-1:<br>:clap:<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><p>去露营了！⛺很快回来。</p><p>真好笑！😂</p><p>:smile:<br>:laughing:</p><p>:+1:<br>:-1:<br>:clap:</p><h2 id><a href="#" class="headerlink" title></a></h2><h1 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h1><p>快速转换源代码模式:ctrl + &#x2F;<br>撤销：Ctrl&#x2F;Command + Z<br>粗体：Ctrl&#x2F;Command + B<br>斜体：Ctrl&#x2F;Command + I<br>插入图片：Ctrl&#x2F;Command + Shift + I<br>插入链接:Ctrl&#x2F;Command + Shift + K<br>删除线:Alt + Shift + 5<br>设置几级标题：Ctrl + 数字(1-5)<br>提升&#x2F;降低标题等级:Ctrl + &#x3D;(-)<br>设置为普通文本:Ctrl + 0(<strong>数字零</strong>)<br>添加有序列表:Ctrl + Shift +[<br>添加无序列表:Ctrl + Shift +]<br>增加缩进:Ctrl +]<br>减少缩进:Ctrl + [<br>添加引用:Ctrl +Shift +Q<br>添加表格:Ctrl +T<br>添加代码块:Ctrl +Shift +K<br>添加下划线:Ctrl+ U<br>添加注释:<!--我是注释--><br>重做：Ctrl&#x2F;Command + Y<br>选择当前词:Ctrl +D<br>选择当前行:Ctrl +L<br>选择当前格式文本:Ctrl +E<br>查找：Ctrl&#x2F;Command + F</p><p>[^要注明的文本内容]: </p><h1 id="Markdown-排版小技巧"><a href="#Markdown-排版小技巧" class="headerlink" title="Markdown 排版小技巧"></a>Markdown 排版小技巧</h1><p>建议<strong>中文和英文之间加空格,中文&#x2F;英文与数据之间也加空格.</strong></p><ol><li><p>一些需要加空格的情况</p><blockquote><p>英文标点符号(,:;?)与后面的字符之间加空格</p><p>当中文或英文使用&gt;(半角)表示路径时,两边加上空格</p></blockquote></li><li><p>不需要加空格的情况</p><blockquote><p>中文标点符号和数字 、中文、英文之间不需要添加空格</p><p>数字和百分号之间不需要添加空格</p><p>数字和单位符号之间不需要添加空格</p><p>英文和数字组成合成的名字不需要添加空格</p><p>当&#x2F;(半角)表示”或”、”路径”时,与前后的字符之间均不加空格</p><p>货币符号后不加空格</p><p>负号后不加空格</p></blockquote></li></ol><p>全角与半角:</p><p>全角:中文标点符号是全角,占两个字节</p><p>半角:英文标点符号是半角,占一个字节</p><p>全角: ，。；：！#</p><p>半角:,.;:!#</p><p>在中文排版中,使用全角标点符号。</p><p>英文排版中,使用半角标点符号。</p><p>专有名词使用正确大小写。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/06/hello-world/"/>
    <url>/2023/09/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
